## JS

#### 基本数据类型和引用数据类型

基本数据类型：数字、字符串、布尔值、null、undefined、symbol
引用数据类型：数组、对象、函数、map、set

基本数据类型的变量中存放的是对应的值，引用数据类型则是保存了一个地址，指向堆内存当中

#### 数据类型检测

typeof 只能检测基本数据类型
instance of 引用数据类型

Object.prototype.toString.call() 最完美的方法

#### 数组

改变原数组
push、pop
shift、unshift
splice：新增、删除、编辑

不影响原数组：concat，合并数组；slice，删除元素

查：find、indexOf、includes
排序：reverse、sort
转字符串：join
迭代：foreach、every、map、some、filter、reduce
判断是否是数组：isArray

#### 字符串

增：concat 拼接、join 从数组拼接
删：substring
改：trim 去空格、toUpperCase 和 toLowCase 转换大小写、replace 替换
查：includes、indexOf
拆分成数组：split

#### 浅拷贝和深拷贝

浅拷贝指的是拷贝变量所指向的值，如果是引用数据类型，拷贝的就是内存地址
常见的浅拷贝方法有 数组的 slice、对象的 assign、扩展运算符

深拷贝则是重新开辟内存空间，将指针指向的堆内存中的数据全部复制过来
一般会使用 JSON 的方法简单实现深拷贝，但如果变量中存在函数就会被忽略，此时可以手写递归实现深拷贝，不断向内部遍历数组或者对象的元素，当该元素通过 typeof 判断不为 object 时退出

#### 作用域链和上下文

作用域指的是函数和变量能被访问的区域，有三种作用域：全局、块级、函数

作用域链指当使用一个变量或者函数时，会先尝试在当前作用域下寻找该变量，找不到时逐级向上层查找，直到找到或是到达全局作用域

#### 事件模型

事件指的是页面中的交互行为，如果事件的触发对象存在父子结构，就会存在触发的顺序问题，也就是事件流

事件流包括三个阶段，事件捕获、事件处理、事件冒泡
事件冒泡指的是由触发节点一直向上传播到根节点的过程，事件捕获则正好相反

一般我们会使用事件冒泡的机制来实现事件代理，比如列表中的每一个元素都触发相同的函数时，就可以将该函数绑定到父元素上，通过自定义属性 data-\* 识别触发的子元素

可以使用 event.stopPropagation()阻止事件冒泡

#### 闭包

闭包是指函数可以记住其词法作用域中的变量，就是可以在内层函数中访问到外层函数的作用域

通常会通过在函数内部嵌套函数，并让内部函数在外部引用来实现

一般会使用闭包实现防抖

```js
// 闭包
function debounce(fn, delay) {
  let timer: unknown = null;
  return function (...args: unknown[]) {
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}

const log = (a, b, c) => {
  console.log(a, b, c);
};

const debouncedFn = debounce(log, 1000);
debouncedFn(1, 2, 3);
```

也可以被用来实现柯里化，当一个函数中存在一个大多数情况下不会改变的参数时，就可以将该参数作为外部函数的入参在内部函数中使用，使用时在调用第一次调用外部函数时传入一次参数，就可以直接使用内部函数进行函数复用

#### 原型

原型是一个对象，为构造函数的实例化对象共享属性和方法

可以通过 prototype 将属性或者方法挂载在构造函数上，实例对象可以使用 Object.getPrototype 访问原型

原型链指的是当对象的属性和方法不存在时，会通过**proto**逐级向上查找，直到顶层原型，即`Object.__proto__`

#### new 的时候具体干了什么

- 创建一个空对象
- 将空对象和构造函数的原型连接
- 绑定构造函数中的 this 到新建对象上
- 判断返回值类型，对象直接返回，基本数据类型则忽略

```js
function mynew(Func, ...args) {
  // 1.创建一个新对象
  const obj = {};
  // 2.新对象原型指向构造函数原型对象
  obj.__proto__ = Func.prototype;
  // 3.将构建函数的this指向新对象
  let result = Func.apply(obj, args);
  // 4.根据返回值判断
  return result instanceof Object ? result : obj;
}
```

#### 继承

ES6 中可以通过 extends 实现继承

ES6 之前可以通过原型链来实现，也就是让子类的原型指向父类的实例对象，但是父类中修改属性后子类中也会改变

构造函数继承：在子类中通过 call 调用父类的构造函数，但是父类中的方法无法继承

组合式继承：子类构造函数中使用 call 调用父类构造函数，然后将子类的原型指向父类的实例化对象，但是父类构造函数执行了两遍

寄生组合式继承：通过 object.create 方法将父类的原型对象浅拷贝过来到子类构造函数上，并将构造器指回自己
`child.prototype.constructor = child;`

#### this 指向

默认绑定到 window 上

如果函数被对象隐式调用，就会绑定到对应的对象上

构造函数的 this 指向实例对象

箭头函数的 this 都会指向 window

可以使用 apply、call、bind 改变 this 的指向

> **apply、call、bind**
>
> 主要作用是改变函数执行上下文，修改 this 的指向
> 三个函数的第一个参数都是 this 指向的对象，后续参数则不痛，apply 是一个参数数组、call 是参数列表、bind 可以多次传入
> bind 返回的是修改 this 后的函数，apply 和 call 则会立刻执行

#### 事件循环

JS 是单线程运行，将所有任务分为了同步任务和异步任务

JS 引擎在解析时会先将同步任务执行完毕后，再依次执行异步任务

异步任务中又包含宏任务和微任务，定时器属于宏任务，Promise 的.then 方法属于微任务，微任务会先于宏任务执行

#### 异步 ajax、promise、async/await

Ajax：
xmlHttpRequest 这个内置对象，创建实例对象，通过 open 方法建立连接，send 进行数据发送，对实例对象的 change 事件进行监听

Promise
promise 具有三种状态：pending、fulfilled、rejected，同时可以通过.then、.catch、.finally 链式调用，避免回掉地狱。构造函数上还提供了.all、.race 等方法，可以将异步任务作为数组参数传入，当所有异步任务全部执行完毕后进入链式调用

async/await
是 promise 的语法糖，将异步任务处理成同步任务的代码格式，但是也需要 try-catch，所以我更习惯使用 promise

#### JS 内存泄露

一般会导致 JS 内存泄漏的原因包括，未进行声明的变量、闭包的滥用、定时器和事件监听没有及时关闭

开发中只需要特别注意以上情况，JS 采取了自动垃圾回收机制，在 V8 引擎中是通过标记清理法实现的这一机制，浏览器会定期标记所有从根节点出发后可以访问到的节点，未被标记的节点会被清理

#### 本地存储

cookies：会在浏览器请求头中携带，存储量小，常被用来做身份验证

localstorage：永久存储，存储时间长，跨页签，可以被用来做单点登录

sessionstorage：单页面存储，由于现在都是单页应用，所以一般都会采取这种存储方案来存储用户的信息

#### 防抖和节流

防抖指如果快速点击，每点击一次，就开启一个定时器并将上一个关闭，永远只执行最后一次点击

节流则是开启一个定时器，无论期间点击多少次，都只执行一次

#### 大文件上传

按照后端要求进行文件拆分

前端对分片数据进行标识

开启上传，可以逐个按顺序上传，也可以同时开启多个异步任务上传

根据后端返回信息判断是否有错漏

断点续传：浏览器返回从哪里开始上传

#### 单点登录

前端实现
将用户信息放入 localstorage 中，在不同域中可以访问到相同的一份用户信息

后端简单实现
从一个网站访问另一个网站时携带上 token，由后端进行校验
