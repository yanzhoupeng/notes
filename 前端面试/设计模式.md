# JS 伪代码实现设计模式

### 单例模式（Singleton）

**场景**：全局唯一的日志管理器

```javascript
class Logger {
  constructor() {
    if (!Logger.instance) {
      this.logs = [];
      Logger.instance = this;
    }
    return Logger.instance;
  }
  log(message) {
    const timestamp = `[2025-10-10 15:19]`; // 使用当前时间
    this.logs.push(`${timestamp}  ${message}`);
    console.log(this.logs[this.logs.length - 1]);
  }
}

// 使用示例
const logger1 = new Logger();
logger1.log(' 系统启动'); // 输出: [2025-10-10 15:19] 系统启动
const logger2 = new Logger();
logger2.log(' 用户登录'); // 仍使用同一实例
```

### 观察者模式（Observer）

**场景**：时间事件订阅系统

```js
class TimeNotifier {
  constructor() {
    this.observers = [];
  }
  addObserver(observer) {
    this.observers.push(observer);
  }
  notify(time) {
    this.observers.forEach((observer) => observer.update(time));
  }
}

class ClockDisplay {
  update(time) {
    console.log(` 当前时间更新: ${time}`);
  }
}

// 使用示例
const notifier = new TimeNotifier();
notifier.addObserver(new ClockDisplay()); // 模拟时间变化
notifier.notify('15:20:00'); // 输出: 当前时间更新: 15:20:00
```

### 工厂模式（Factory）

**场景**：动态创建不同格式的时间处理器

```js
class TimeFormatterFactory {
  static create(type) {
    switch (type) {
      case 'short':
        return new ShortTimeFormatter();
      case 'long':
        return new LongTimeFormatter();
      default:
        throw new Error('未知格式类型');
    }
  }
}

class ShortTimeFormatter {
  format() {
    return '2025-10-10';
  }
}

// 使用示例
const formatter = TimeFormatterFactory.create('short');
console.log(formatter.format()); // 输出: 2025-10-10
```

### 策略模式（Strategy）

**场景**：灵活的日期计算策略

```js
class DateCalculator {
  constructor(strategy) {
    this.strategy = strategy;
  }
  calculate(date) {
    return this.strategy.execute(date);
  }
}

class AddDayStrategy {
  execute(date) {
    return new Date(date.setDate(date.getDate() + 1)); // 加1天
  }
}

// 使用示例
const calculator = new DateCalculator(new AddDayStrategy());
const nextDay = calculator.calculate(new Date(2025, 9, 10)); // 注意月份是0-based
console.log(nextDay.toISOString()); // 输出: 2025-10-11T...
```

### 装饰器模式（Decorator）

**场景**：扩展基础日志功能

```js
class BasicLogger {
  log(message) {
    console.log(message);
  }
}

class TimestampDecorator {
  constructor(logger) {
    this.logger = logger;
  }
  log(message) {
    this.logger.log(`[2025-10-10]  ${message}`);
  }
}

// 使用示例
const decoratedLogger = new TimestampDecorator(new BasicLogger());
decoratedLogger.log(' 警告：内存不足'); // 输出: [2025-10-10] 警告：内存不足
```

选择建议

- **单例**：全局状态管理（如配置、日志）
- **观察者**：事件驱动场景（如 UI 更新）
- **工厂**：需要隐藏对象创建细节时
- **策略**：算法可动态替换（如日期计算、排序）
- **装饰器**：动态扩展对象功能
