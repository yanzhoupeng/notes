元素之间为一对一的关系

根据插入、删除元素的方式，可以分为以下几种结构

- [数组](#数组)
- [列表](#列表)
- [链表](#链表)
- [栈](#栈)
- [队列](#队列)
- [双端队列](#双端队列)

## 数组

数组是一种线性结构，将**相同数据类型**的元素存储于相邻的内存单元，元素在数组中的位置称为索引，索引从0开始计数，具有**随机存取**的特性

**索引值本质上是内存地址的偏移量**

#### 常用操作

- 初始化数组
- 访问元素
- 插入元素
- 删除元素
- 遍历数组
- 搜索元素
- 扩容

```python
# 创建数组
arr = [1, 2, 3]
  
# 访问元素
item = arr[0]

# 插入元素 index为索引值
# 需要注意 数组为定长的数据类型 末尾元素将会溢出
def insert(array, item, index):
	for i in range(len(array) - 1, index, -1):
		array[i] = array[i - 1]
	array[index] = item
  
# 删除元素
def remove(array, index):
	for i in range(index, len(array) - 1):
		array[i] = array[i + 1]

# 遍历数组
for i in range(len(arr)):
	print(arr[i])

# 数组扩容
def extend(array, enlarge):
	res = [0] * (len(array) + enlarge)
	for i in range(len(array)):
		res[i] = array[i]
	return res
```

## 列表



## 链表

## 栈

#### 特点

后进先出

#### 实现

```python
class Stack:
	def __init__(self):
		self.items = []

	def is_empty(self):
		return len(self.items) == 0

	def push(self, item):
		self.items.append(item)

	def pop(self):
		return self.items.pop()

	def size(self):
		return len(self.items)

	def peek(self):
		# 取栈顶元素 并不删除
		if not self.is_empty():
			return self.items[-1]
		return None
```

#### 练习

1.括号匹配

```python
def test(str):
	pos = 0
	flag = True
	my_stack = Stack()

	while pos < len(str) and flag:
		if str[pos] == "(":
			# 左括号直接入栈
			my_stack.push(str[pos])
		elif str[pos] == ")":
			# 右括号进行匹配
			if my_stack.is_empty():
				flag = False
			else:
				my_stack.pop()
			# 继续处理下一个字符
			pos += 1

	return my_stack.is_empty() and flag
```

2.二进制转换

```python
def to_binary(num):
	mstack = Stack()
	while num > 0:
		mstack.push(num % 2)
		num = num // 2 # 整除

	binary = ""
	while not mstack.is_empty():
		binary += str(mstack.pop())

	return binary
```

3.表达式转换

- 运算数的位置永远不会改变，运算符的远近决定了执行的顺序
- 手工处理思路
  - 将表达式转换成全括号表达式，前缀表达式将运算符移动到左括号处，后缀表达式将运算符移动到右括号处

* 代码实现思路
  - 从左到右扫描表达式
  - 运算数直接放入后缀表达式列表
  - 遇到左括号，放入运算符栈
  - 遇到右括号，将运算符栈中所有运算符输出到后缀表达式列表，直到遇到左括号
  - 如果是普通操作符
    - 和栈顶运算符比较，若优先级小于等于栈顶运算符，则将栈顶运算符输出
    - 直到栈顶运算符的优先级小于它
  - 最后将运算符栈中的所有元素输出到后缀表达式列表
  - 使用 join 方法拼接

```python
def infix_to_postfix(expression):
	prec = {"(": 0, "+": 1, "-": 1, "*": 2, "/": 2, "^": 3}
	tokenList = expression.split()
	opStack = Stack()
	postfix = []

	for token in tokenList:
		if token in "ABCDEFGHIJKLMNOPQRSTUVWXYZ" or token in "0123456789":
			postfix.append(token)
		elif token == "(":
			opStack.push(token)
		elif token == ")":
			while not opStack.peek() == "(":
				postfix.append(opStack.pop())
		else:
			while (not opStack.is_empty()) and (prec[opStack.peek()] >= prec[token]): # type: ignore
				postfix.append(opStack.pop())
			opStack.push(token)

	while not opStack.is_empty():
		postfix.append(opStack.pop())

	return " ".join(postfix)
```

4.后缀表达式求值

```python
def postfix_eval(expression):
	opStack = Stack()
	tokenList = expression.split()

	for token in tokenList:
		if token in "0123456789":
			opStack.push(token)
		else:
			opRight = opStack.pop()
			opLeft = opStack.pop()
			opStack.push(mathOption(float(opLeft), float(opRight), token))

	return opStack.pop()


def mathOption(left, right, operator):
	if operator == "+":
		return left + right
	elif operator == "-":
		return left - right
	elif operator == "*":
		return left * right
	elif operator == "/":
		return left / right
	elif operator == "^":
		return left**right
	else:
		raise ValueError(f"Unknown operator: {operator}")
```

### 队列

#### 特点

先进先出

### 双端队列
