# 1. 线性结构

### 1. 定义

每一个元素都只有唯一的前驱和后续

### 2. 基本线性结构

- 根据插入、删除元素的方式，可以分为以下几种结构
- 栈
- 队列
- 双端队列
- 列表

### 3. 栈 stack

#### 特点

后进先出

#### 实现

```python
class Stack:
	def __init__(self):
		self.items = []

	def is_empty(self):
		return len(self.items) == 0

	def push(self, item):
		self.items.append(item)

	def pop(self):
		return self.items.pop()

	def size(self):
		return len(self.items)

	def peek(self):
		# 取栈顶元素 并不删除
		if not self.is_empty():
			return self.items[-1]
		return None
```

#### 练习

1.括号匹配

```python
def test(str):
	pos = 0
	flag = True
	my_stack = Stack()

	while pos < len(str) and flag:
		if str[pos] == "(":
			# 左括号直接入栈
			my_stack.push(str[pos])
		elif str[pos] == ")":
			# 右括号进行匹配
			if my_stack.is_empty():
				flag = False
			else:
				my_stack.pop()
			# 继续处理下一个字符
			pos += 1

	return my_stack.is_empty() and flag
```

2.二进制转换

```python
def to_binary(num):
	mstack = Stack()
	while num > 0:
		mstack.push(num % 2)
		num = num // 2 # 整除

	binary = ""
	while not mstack.is_empty():
		binary += str(mstack.pop())

	return binary
```

3.表达式转换

- 运算数的位置永远不会改变，运算符的远近决定了执行的顺序
- 手工处理思路
  - 将表达式转换成全括号表达式，前缀表达式将运算符移动到左括号处，后缀表达式将运算符移动到右括号处

* 代码实现思路
  - 从左到右扫描表达式
  - 运算数直接放入后缀表达式列表
  - 遇到左括号，放入运算符栈
  - 遇到右括号，将运算符栈中所有运算符输出到后缀表达式列表，直到遇到左括号
  - 如果是普通操作符
    - 和栈顶运算符比较，若优先级小于等于栈顶运算符，则将栈顶运算符输出
    - 直到栈顶运算符的优先级小于它
  - 最后将运算符栈中的所有元素输出到后缀表达式列表
  - 使用 join 方法拼接

```python
def infix_to_postfix(expression):
	prec = {"(": 0, "+": 1, "-": 1, "*": 2, "/": 2, "^": 3}
	tokenList = expression.split()
	opStack = Stack()
	postfix = []

	for token in tokenList:
		if token in "ABCDEFGHIJKLMNOPQRSTUVWXYZ" or token in "0123456789":
			postfix.append(token)
		elif token == "(":
			opStack.push(token)
		elif token == ")":
			while not opStack.peek() == "(":
				postfix.append(opStack.pop())
		else:
			while (not opStack.is_empty()) and (prec[opStack.peek()] >= prec[token]): # type: ignore
				postfix.append(opStack.pop())
			opStack.push(token)

	while not opStack.is_empty():
		postfix.append(opStack.pop())

	return " ".join(postfix)
```

4.后缀表达式求值

```python
def postfix_eval(expression):
	opStack = Stack()
	tokenList = expression.split()

	for token in tokenList:
		if token in "0123456789":
			opStack.push(token)
		else:
			opRight = opStack.pop()
			opLeft = opStack.pop()
			opStack.push(mathOption(float(opLeft), float(opRight), token))

	return opStack.pop()


def mathOption(left, right, operator):
	if operator == "+":
		return left + right
	elif operator == "-":
		return left - right
	elif operator == "*":
		return left * right
	elif operator == "/":
		return left / right
	elif operator == "^":
		return left**right
	else:
		raise ValueError(f"Unknown operator: {operator}")
```

### 4. 队列 queue

#### 特点

先进先出

### 5. 双端队列

### 6. 无序列表

### 7. 有序列表

