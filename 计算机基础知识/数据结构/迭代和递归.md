# 迭代

### for 循环

range()函数是左闭右开，下例为 1+2+...+9 的和

```python
res = 0
for i in range(1, 10):
	res += i
print(res)
```

### while 循环

while 循环自由度更高，可以定义无限循环，当满足条件后终止循环；也可以在循环体内对循环条件进行多次自定义更新

```python
while(True):
	if xxx:
		break
	xxx
```

### 循环嵌套

```python
def nested_for_loop(n: int) -> str:
    res = ""
    # 循环 i = 1, 2, ..., n-1, n
    for i in range(1, n + 1):
        # 循环 j = 1, 2, ..., n-1, n
        for j in range(1, n + 1):
            res += f"({i}, {j}), "
    return res
```

# 递归

### 什么是递归

**两个阶段**

**递**：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”
**归**：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果

**三个要素**

**终止条件**：用于决定什么时候由“递”转“归”
**递归调用**：对应“递”，函数调用自身，通常输入更小或更简化的参数
**返回结果**：对应“归”，将当前递归层级的结果返回至上一层

```python
def recur(n: int) -> int:
    # 终止条件
    if n == 1:
        return 1
    # 递：递归调用
    res = recur(n - 1)
    # 归：返回结果
    return n + res
```

**运行过程**：

![[Pasted image 20250828112639.png]]

### 调用栈

递归函数在‘递’的过程中，会为新开启的函数分配内存，存储变量、地址等其他信息，放入栈中，直到函数返回结果才会释放。

- 递归比常规函数更占用内存
- 递归通常比常规函数的时间效率更低

### 分治

从本质上看，递归体现了“将问题分解为更小子问题”的思维范式，这种分治策略至关重要

**例：斐波那契数列**

设斐波那契数列的第 n 个数字为 fib(n)，易得两个结论。

- 数列的前两个数字为 fib(1)=0 和 fib(2)=1
- 数列中的每个数字是前两个数字的和，即 fib(n - 1) + fib(n - 2)

```python
def fib(n: int) -> int:
	if n == 1 or n == 2:
		return n - 1
	res = fib(n - 1) + fib(n - 2)
	return res
```

![[Pasted image 20250828113243.png]]
